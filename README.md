<h1>1.1</h1>
<h2>Формулировка</h2>

Дробная часть.<br />
Дана сигнатура метода: public double fraction (double x);<br />
Необходимо реализовать метод таким образом, чтобы он возвращал только <br />
дробную часть числа х. Подсказка: вещественное число может быть <br />
преобразовано к целому путем отбрасывания дробной части.<br />
Пример:
x=5,25<br />
результат: 0,25

<h2>Алгоритм решения</h2>

1. Получаем целую часть числа через Convert.<br />
2. Вычитаем из передаваемого числа его целую часть.

<h1>1.3</h1>
<h2>Формулировка</h2>

Букву в число.<br />
Дана сигнатура метода: public int charToNum (char x);<br />
Метод принимает символ х, который представляет собой один из “0 1 2 3 4 5 6 7 <br />
8 9”. Необходимо реализовать метод таким образом, чтобы он преобразовывал <br />
символ в соответствующее число. Подсказка: код символа ‘0’ — это число 48.<br />
Пример:<br />
x=’3’<br />
результат: 3

<h2>Алгоритм решения</h2>

1. конвертируем символ в код числа из таблицы ascii с помощью метода Convert.<br />
2. возвращаем число минус код нуля

<h1>1.5</h1>
<h2>Формулировка</h2>

Двузначное. <br />
Дана сигнатура метода: public bool is2Digits (int x);<br />
Необходимо реализовать метод таким образом, чтобы он принимал число x и <br />
возвращал true, если оно двузначное. <br />
Пример 1:<br />
x=32<br />
результат: true<br />
Пример 2:<br />
x=516<br />
результат: false

<h2>Алгоритм решения</h2>

1. Если x больше 9 и меньше 100, вернуть true.<br />
2. В остальных случаях вернуть false.<br />

<h1>1.7</h1>
<h2>Формулировка</h2>

Диапазон. <br />
Дана сигнатура метода: public bool isInRange (int a, int b, int num);
Метод принимает левую и правую границу (a и b) некоторого числового 
диапазона. Необходимо реализовать метод таким образом, чтобы он возвращал
true, если num входит в указанный диапазон (включая границы). Обратите 
внимание, что отношение a и b заранее неизвестно (неясно кто из них больше, а 
кто меньше)<br />
Пример 1:<br />
a=5 b=1 num=3<br />
результат: true<br />
Пример 2:<br />
a=2 b=15 num=33<br />
результат: false

<h2>Алгоритм решения</h2>

1. Определяем минимальную и максимальную границу диапазона с помощью Math.Min и Math.Max.<br />
2. Проверяем условие: число >= минимальной границы и <= максимальной границы.<br />
3. Если условие выполняется, возвращаем true, иначе false.<br />

<h1>1.9</h1>
<h2>Формулировка</h2>

Равенство. <br />
Дана сигнатура метода: public bool isEqual(int a, int b, int c);
Необходимо реализовать метод таким образом, чтобы он возвращал true, если 
все три полученных методом числа равны<br />
Пример 1:<br />
a=3 b=3 с=3<br />
результат: true<br />
Пример 2:<br />
a=2 b=15 с=2<br />
результат: false

<h2>Алгоритм решения</h2>

1. Сравниваем первое число со вторым и второе с третьим.<br />
2. Если оба условия выполняются, возвращаем true.<br />
3. В противном случае возвращаем false.<br />

<h1>2.1</h1>
<h2>Формулировка</h2>

Модуль числа. <br />
Дана сигнатура метода: public int abs (int x);<br />
Необходимо реализовать метод таким образом, чтобы он возвращал модуль <br />
числа х (если оно было положительным, то таким и остается, если он было <br />
отрицательным – то необходимо вернуть его без знака минус).<br />
Пример 1:<br />
x=5<br />
результат: 5<br />
Пример 2:<br />
x=-3<br />
результат: 3

<h2>Алгоритм решения</h2>

1. Если x меньше нуля, возвращаем -1 * x, чтобы убрать минус<br />
2. Иначе возвращаем x

<h1>2.3</h1>
<h2>Формулировка</h2>

Тридцать пять.<br />
Дана сигнатура метода: public bool is35 (int x);<br />
Необходимо реализовать метод таким образом, чтобы он возвращал true, если<br />
число x делится нацело на 3 или 5. При этом, если оно делится и на 3, и на 5, то<br />
вернуть надо false. Подсказка: оператор % позволяет получить остаток от деления.<br />
Пример 1:<br />
x=5<br />
результат: true<br />
Пример 2:<br />
x=8<br />
результат: false<br />
Пример 3:<br />
x=15<br />
результат: false

<h2>Алгоритм решения</h2>

1. Проверяем делится ли x на 3 и 5 одновременно и возвращаем false, если это так<br>
2. Если число делится только на 3 или только на 5, то возвращаем true<br>
3. Если число не делится ни на 3, ни на 5, возвращаем false
<h1>2.5</h1>
<h2>Формулировка</h2>

Тройной максимум.<br />
Дана сигнатура метода: public int max3 (int x, int y, int z);<br />
Необходимо реализовать метод таким образом, чтобы он возвращал<br />
максимальное из трех полученных методом чисел. Подсказка: идеальное<br />
решение включает всего две инструкции if и не содержит вложенных if.<br />
Пример 1:<br />
x=5 y=7 z=7<br />
результат: 7<br />
Пример 2:<br />
x=8 y=-1 z=4<br />
результат: 8

<h2>Алгоритм решения</h2>

1. Сравнить первое число с двумя другими: если оно больше либо равно обоим — вернуть его.<br />
2. Иначе сравнить второе число с двумя другими: если оно больше либо равно обоим — вернуть его.<br />
3. Если оба условия выше не выполняются — вернуть третье число.<br />

<h1>2.7</h1>
<h2>Формулировка</h2>

Двойная сумма.<br />
Дана сигнатура метода: public int sum2 (int x, int y);<br />
Необходимо реализовать метод таким образом, чтобы он возвращал сумму<br />
чисел x и y. Однако, если сумма попадает в диапазон от 10 до 19, то надо вернуть
число 20.<br />
Пример 1:<br />
x=5 y=7<br />
результат: 20<br />
Пример 2:<br />
x=8 y=-1<br />
результат: 7

<h2>Алгоритм решения</h2>

1. Найти сумму чисел x и y.<br />
2. Если сумма находится в диапазоне от 10 до 19 включительно, вернуть 20.<br />
3. В противном случае вернуть найденную сумму.<br />

<h1>2.9</h1>
<h2>Формулировка</h2>

День недели.<br />
Дана сигнатура метода: public String day (int x);<br />
Метод принимает число x, обозначающее день недели. Необходимо реализовать<br />
метод таким образом, чтобы он возвращал строку, которая будет обозначать<br />
текущий день недели, где 1- это понедельник, а 7 – воскресенье. Если число не<br />
от 1 до 7 то верните текст “это не день недели”. Вместо if в данной задаче
используйте switch.<br />
Пример:<br />
x=5<br />
результат: “пятница”

<h2>Алгоритм решения</h2>

1. Использовать оператор switch для проверки значения x.<br />
2. Для значений от 1 до 7 вернуть название дня недели.<br />
3. Если значение не попадает в диапазон, вернуть строку "Это не день недели".<br />

<h1>3.1</h1>
<h2>Формулировка</h2>

Числа подряд.<br />
Дана сигнатура метода: public String listNums (int x);<br />
Необходимо реализовать метод таким образом, чтобы он возвращал строку, в<br />
которой будут записаны все числа от 0 до x (включительно).<br />
Пример:<br />
x=5<br />
результат: “0 1 2 3 4 5”

<h2>Алгоритм решения</h2>

1. Создать пустую строку.<br />
2. С помощью цикла for от 0 до x добавлять в строку текущее число и пробел.<br />
3. Вернуть полученную строку.<br />

<h1>3.3</h1>
<h2>Формулировка</h2>

Четные числа.<br />
Дана сигнатура метода: public String chet (int x);<br />
Необходимо реализовать метод таким образом, чтобы он возвращал строку, в<br />
которой будут записаны все четные числа от 0 до x (включительно). <br />
Подсказка: для обеспечения качества кода: инструкцию if использовать не следует.<br />
Пример:<br />
x=9<br />
результат: “0 2 4 6 8”

<h2>Алгоритм решения</h2>

1. Создать пустую строку.<br />
2. С помощью цикла for с шагом 2 от 0 до x добавлять текущее число и пробел.<br />
3. Вернуть полученную строку.<br />

<h1>3.5</h1>
<h2>Формулировка</h2>

Длина числа.<br />
Дана сигнатура метода: public int numLen (long x);<br />
Необходимо реализовать метод таким образом, чтобы он возвращал количество<br />
знаков в числе x.<br />
Подсказка:<br />
Int у=123/10; // у будет иметь значение 12<br />
Пример:<br />
x=12567<br />
результат: 5

<h2>Алгоритм решения</h2>

1. Создать счётчик цифр, равный 0.<br />
2. Пока число больше 0, делить его на 10 и увеличивать счётчик.<br />
3. Когда число станет 0, вернуть счётчик.<br />

<h1>3.7</h1>
<h2>Формулировка</h2>

Квадрат.<br />
Дана сигнатура метода: public void square (int x);<br />
Необходимо реализовать метод таким образом, чтобы он выводил на экран<br />
квадрат из символов ‘*’ размером х, у которого х символов в ряд и х символов в
высоту.<br />
Пример 1:<br />
x=2<br />
результат:<br />
**<br />
**<br />
Пример 2:<br />
x=4<br />
результат:<br />
****<br />
****<br />
****<br />
****

<h2>Алгоритм решения</h2>

1. С помощью внешнего цикла for выполнить x итераций (строки).<br />
2. На каждой итерации формировать строку из x символов '*' с помощью внутреннего цикла.<br />
3. Вывести строку на экран.<br />

<h1>3.9</h1>
<h2>Формулировка</h2>

Правый треугольник.<br />
Дана сигнатура метода: public void rightTriangle (int x);<br />
Необходимо реализовать метод таким образом, чтобы он выводил на экран<br />
треугольник из символов ‘*’ у которого х символов в высоту, а количество<br />
символов в ряду совпадает с номером строки, при этом треугольник выровнен<br />
по правому краю. Подсказка: перед символами ‘*’ следует выводить<br />
необходимое количество пробелов.<br />
Пример 1:<br />
x=3<br />
результат:<br />
 *<br />
 **<br />
 ***<br />
Пример 2:<br />
x=4<br />
результат:<br />
 *<br />
 **<br />
 ***<br />
 ****

<h2>Алгоритм решения</h2>

1. С помощью цикла от 1 до x выводить строки.<br />
2. Для каждой строки сначала печатать (x - i) пробелов.<br />
3. Затем печатать i символов '*'.<br />
4. Вывести строку на экран<br />

<h1>4.1</h1>
<h2>Формулировка</h2>

Поиск первого значения.<br />
Дана сигнатура метода: public int findFirst (int[] arr, int x);<br />
Необходимо реализовать метод таким образом, чтобы он возвращал индекс<br />
первого вхождения числа x в массив arr. Если число не входит в массив –<br />
возвращается -1.<br />
Пример:<br />
arr=[1,2,3,4,2,2,5]<br />
x=2<br />
результат: 1

<h2>Алгоритм решения</h2>

1. С помощью цикла пройти по всем элементам массива.<br />
2. Если текущий элемент равен x, вернуть его индекс.<br />
3. Если ни одного совпадения не найдено — вернуть -1.<br />

<h1>4.3</h1>
<h2>Формулировка</h2>

Поиск максимального.<br />
Дана сигнатура метода: public int maxAbs (int[] arr);<br />
Необходимо реализовать метод таким образом, чтобы он возвращал<br />
наибольшее по модулю (то есть без учета знака) значение массива arr.<br />
Пример:<br />
arr=[1,-2,-7,4,2,2,5]<br />
результат: -7

<h2>Алгоритм решения</h2>

1. Создать переменную для хранения максимального значения по модулю.<br />
2. Пройти по массиву в цикле.<br />
3. Для каждого элемента вычислить его модуль с помощью Math.Abs.<br />
4. Если оно больше текущего максимума — обновить максимум.<br />
5. После завершения цикла вернуть максимальное значение.<br />

<h1>4.5</h1>
<h2>Формулировка</h2>

Добавление массива в массив.<br />
Дана сигнатура метода: public int[] add (int[] arr, int[] ins, int pos);<br />
Необходимо реализовать метод таким образом, чтобы он возвращал новый<br />
массив, который будет содержать все элементы массива arr, однако в позицию<br />
pos будут вставлены значения массива ins.<br />
Пример:<br />
arr=[1,2,3,4,5]<br />
ins=[7,8,9]<br />
pos=3<br />
результат: [1,2,3,7,8,9,4,5]

<h2>Алгоритм решения</h2>

1. Создать новый массив длиной arr.Length + ins.Length.<br />
2. Скопировать элементы arr до позиции pos в новый массив.<br />
3. Добавить все элементы массива ins.<br />
4. Добавить оставшиеся элементы массива arr после pos.<br />
5. Вернуть новый массив.<br />

<h1>4.7</h1>
<h2>Формулировка</h2>

Возвратный реверс.<br />
Дана сигнатура метода: public int[] reverseBack (int[] arr);<br />
Необходимо реализовать метод таким образом, чтобы он возвращал новый<br />
массив, в котором значения массива arr записаны задом наперед.<br />
Пример:<br />
arr=[1,2,3,4,5]<br />
результат: [5,4,3,2,1]

<h2>Алгоритм решения</h2>

1. Создать новый массив такой же длины, как исходный.<br />
2. С помощью цикла пройти по arr от конца к началу.<br />
3. Копировать элементы в новый массив начиная с нулевого индекса.<br />
4. Вернуть полученный массив.<br />

<h1>4.9</h1>
<h2>Формулировка</h2>

Все вхождения.<br />
Дана сигнатура метода: public int[] findAll (int[] arr, int x);<br />
Необходимо реализовать метод таким образом, чтобы он возвращал новый<br />
массив, в котором записаны индексы всех вхождений числа x в массив arr.<br />
Пример:<br />
arr=[1,2,3,8,2,2,9]<br />
x=2<br />
результат: [1,4,5]

<h2>Алгоритм решения</h2>

1. Создать массив индексов.<br />
2. С помощью цикла пройти по массиву arr.<br />
3. Если текущий элемент равен x, добавить его индекс в массив.<br />
4. После завершения цикла вернуть массив индексов.<br />